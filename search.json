[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FLA 2026 Lecture Notes",
    "section": "",
    "text": "Preface\nThis book is a collection of lecture notes for COMS3003A and COMS3021A.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "lectures/lecture_1.html",
    "href": "lectures/lecture_1.html",
    "title": "1  An Introduction to Theoretical Computer Science",
    "section": "",
    "text": "Maybe one day I will write something for this page…",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>An Introduction to Theoretical Computer Science</span>"
    ]
  },
  {
    "objectID": "lectures/lecture_2.html",
    "href": "lectures/lecture_2.html",
    "title": "2  Data, Representations, and Problems",
    "section": "",
    "text": "2.1 Data",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data, Representations, and Problems</span>"
    ]
  },
  {
    "objectID": "lectures/lecture_2.html#data",
    "href": "lectures/lecture_2.html#data",
    "title": "2  Data, Representations, and Problems",
    "section": "",
    "text": "2.1.1 Primitive Data\nSymbols: The most basic unit - may be anything that can be Read & Written\n\nNumbers: \\(0, 1\\)\nLatin Letters: \\(A, B, C, ..., Y, Z\\)\nGreek Letters: \\(\\alpha, \\beta\\)\nElectricity: \\(1.5V\\), \\(3.0V\\)\nSound\n\nAlphabet: A finite set of symbols\n\nCommon notation \\(\\Sigma\\), \\(\\Gamma\\), \\(\\Delta\\)\n\nStrings / Words:\n\nA finite sequence of symbols\n\\(\\varepsilon\\) is the empty word\nWords have a length \\(|w| = n \\iff \\text{there are } n \\text{ symbols in } w\\)\n\n\\(|\\varepsilon| = 0\\)\n\n\nString Operators:\n\nConcatenation - connecting two symbols or strings\n\n\\(w_1 \\circ w_2 = w_1 w_2\\)\n\nRepeat Concatenation - concatenate the same string the specified number of times\n\n\\(w^n = w \\circ w \\circ w \\:\\circ\\: ... \\:\\circ\\: w\\)\n\n\n\n\n2.1.2 Describing Strings\nString Generators: Describe a set of strings\n\nUnion - Either string\n\n\\(w \\cup v = \\{\\; w, v \\;\\}\\)\n\nKleene Star - Repeat the string any numbers of times\n\n\\(w^\\ast = \\{\\; \\varepsilon, w, ww, www, wwww, ... \\;\\}\\)\n\nKleene Plus - repeat the string at least once\n\n\\(w^+ = w w^\\ast =\\{\\; w, ww, www, ... \\;\\}\\)\n\nOtherwise called a regular expression\n\nThe set of all strings over an alphabet is \\[ \\Sigma^\\ast \\]\n\n\n\n\n\n\nNote\n\n\n\nLet \\(\\Sigma = \\{\\: a , b \\:\\}\\) \\[\\Sigma^\\ast = \\left\\{\\: \\begin{matrix} \\varepsilon, \\\\ a, aa, aaa, ... \\\\ b, bb, bbb, ... \\\\ ab, aba, abaa, ... \\\\ abba, abbaa, abbaaa, ... \\end{matrix} \\:\\right\\}\\]\n\n\n\n\n2.1.3 Languages\nA language \\(L\\) is a set of strings (i.e. a subset of \\(\\Sigma^\\ast\\))\n\n\n\n\n\n\nTipNotation\n\n\n\nAs shorthand, we may specify a set \\(L\\) is a language by indicating that it is a subset of all strings. \\[ L \\subseteq \\Sigma^\\ast \\]\n\n\nLanguage Examples:\n\nThe set of all strings with two symbols \\[ \\{ w \\in \\Sigma^\\ast \\mid |w| = 2 \\} \\]\nThe set of all strings that end in 0 \\[ \\{ w \\in \\Sigma^\\ast \\mid w = v \\circ u \\text{ and } u = 0 \\} \\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data, Representations, and Problems</span>"
    ]
  },
  {
    "objectID": "lectures/lecture_2.html#representations",
    "href": "lectures/lecture_2.html#representations",
    "title": "2  Data, Representations, and Problems",
    "section": "2.2 Representations",
    "text": "2.2 Representations\nA representation is an interpretation of objects into strings\nIf I give you 5 objects, how would you label them? How about 10 objects? What about an infinite number of objects?\nFormally, a representation is a mapping from a set of objects \\(X\\) to a string \\[ r: X \\mapsto \\Sigma^\\ast\\]\nWe also want to add the following properties to our representation:\n\nEvery input has some output \\[ \\forall x \\in X, \\exists w \\in \\Sigma^\\ast, r(x) = w \\]\nEvery output has at least one input \\[ \\forall w \\in \\Sigma^\\ast, \\exists x \\in X, r(x) = w \\]\nIf two inputs are different, their outputs must be different \\[ \\forall x,y \\in X,  x \\neq y \\implies r(x) \\neq r(y) \\]\n\n\n\n\n\n\n\nNoteA brief interlude on relations\n\n\n\nA relation \\(\\alpha: X \\mapsto Y\\) is the more general idea of a function. A function \\(f: X \\mapsto Y\\) requires that each \\(x \\in X\\) maps to only one \\(y \\in Y\\). Relations are a relaxation of that to-one property (called functional). Our first property of all \\(x \\in X\\) having at least one \\(y \\in Y\\) is called serial.\nAnother way to think of relations is using sets. A binary Relation \\(R: X \\mapsto Y\\) is the subset \\(R \\subseteq X \\times Y\\). Notationally, we say \\(x\\:R\\:y\\) (\\(x\\) relates to \\(y\\) by \\(R\\)) if \\((x,y) \\in R\\)\nAn example is equality of numbers \\(=: \\mathbb{R} \\mapsto \\mathbb{R}\\) \\[\\forall x, y \\in \\mathbb{R}, x = y \\iff (x,y) \\in \\{\\:\\ (a,a) \\mid a \\in \\mathbb{R} \\:\\}\\]\n\n\n\n\n\n\n\n\nTipNotation\n\n\n\nInstead of writing \\(r(x)\\) we will write \\(\\left&lt; x \\right&gt;_r\\) to mark it as a string\nIf it is clear what representation we are using, then we can drop the \\(r\\)\n\n\nA representation allows us to take random objects and ‘insert’ them into strings, but we also want to be able to ‘extract’ an object out of a string.\nSo we add the additional requirement that our representation must be invertible. We define some default value for \\(X\\). If the string cannot be identified, we just map it to this default value.\n\n\n\n\n\n\nWarning\n\n\n\nWe are hand-waving away a fairly important problem. Two strings may represent the same object, for example in decimal numbers: 0.99999… = 1\nAs an exercise, try write a more rigorous definition of a representation using a tool you were taught in abstract maths (hint: equivalence)\n\n\n\n2.2.1 Natural Numbers \\(\\mathbb{N}\\) in an alphabet of \\(k\\) symbols\n\\[\n    \\forall n \\in \\mathbb{N}, \\left&lt; n \\right&gt;_{\\mathbb{N}, k} = \\text{The base-} k \\text{ encoding of } n\n\\]\nBy default, we will use \\(k = 2\\). If the \\(k\\) is left off, then assume it is 2\n\n\n2.2.2 Integers \\(\\mathbb{Z}\\) in an alphabet of \\(k\\) symbols:\n\\[\\forall z \\in \\mathbb{Z}, \\left&lt; z \\right&gt;_{\\mathbb{Z}, k} = \\begin{cases}\n    0 \\circ \\left&lt;|z|\\right&gt;_{\\mathbb{N}, k} \\text{ if } z \\geq 0 \\\\\n    1 \\circ \\left&lt;|z|\\right&gt;_{\\mathbb{N}, k} \\text{ if } z &lt; 0\n\\end{cases}\\]\n\n\n\n\n\n\nWarning\n\n\n\nWhat does the string \\(00\\) mean in this representation?\nThis is where our “default” value for a “garbage” string comes into play. We cannot recogize \\(00\\) according to our rules, so we instead just map it to the integer \\(0\\).\n\n\n\n\n2.2.3 Rationals \\(\\mathbb{Q}\\) in an alphabet of \\(k\\) symbols\n\\[ \\forall \\frac{x}{y} \\in \\mathbb{Q}, \\left&lt;\\frac{x}{y}\\right&gt;_{\\mathbb{Q},k} = \\left&lt;x\\right&gt;_{\\mathbb{Z}, k}\\#\\left&lt;y\\right&gt;_{\\mathbb{Z},k}\\] We’ve had to add the symbol \\(\\#\\) to separate our integers in the fraction. We can simplify this down into just our alphabet of \\(k\\) symbols.\nTo pull a rational number out of a string, we use the reverse of the above, but if we cannot recognize the string, we instead default to \\(0\\).\nBinary simplifier example: \\[ e_2(x) = \\begin{cases}\n    00 \\quad\\text{ if } x = 0 \\\\\n    01 \\quad\\text{ if } x = 1 \\\\\n    10 \\quad\\text{ if } x = \\# \\\\\n    11 \\quad\\text{ otherwise }\n\\end{cases}\n\\]\n\n\n2.2.4 Booleans\n\\[\n    \\left&lt; b \\right&gt;_{\\mathbb{B},k} = \\begin{cases}\n        1 & \\text{if } b = \\text{True} \\\\\n        0 & \\text{if } b = \\text{False}\n    \\end{cases}\n\\]\n\n\n2.2.5 Complex Objects\nWe know have a fairly robust set of primitive representations. We can encode natural numbers, integers, rationals, and booleans, but how can we encode a more complex object? One that is made up of several sub-objects?\nIf our object has 2 components (imagine a 2D vector), we can employ the same separation as our rationals.\n\\[ \\left&lt; \\left(\\begin{matrix}x\\\\ y\\end{matrix}\\right) \\right&gt; := \\left&lt;x\\right&gt; \\# \\left&lt;y\\right&gt; \\]\nFor \\(m\\) components? \\[ \\left&lt; \\left(\\begin{matrix} a_1\\\\ a_2 \\\\ \\vdots \\\\ a_m \\end{matrix}\\right) \\right&gt; := \\left&lt;a_1\\right&gt; \\# \\left&lt;a_2\\right&gt; \\# ... \\# \\left&lt;a_m\\right&gt;\\]\n\n\n\n\n\n\nWarningWhat if we have a vector of rationals?\n\n\n\nWe use \\(\\#\\) as a separator for both our vector components and our numerator and denominator. This is a collision of meaning. How can we write something like \\[ \\begin{pmatrix} \\frac{a}{b} \\\\ \\frac{c}{d} \\end{pmatrix}\\] Our current encoding of this just becomes \\[\\left&lt;\\begin{pmatrix} \\frac{a}{b} \\\\ \\frac{c}{d} \\end{pmatrix}\\right&gt; = \\left&lt;a\\right&gt;\\#\\left&lt;b\\right&gt;\\#\\left&lt;c\\right&gt;\\#\\left&lt;d\\right&gt;\\] which is either a 4D integer vector, a 3D vector in \\(\\mathbb{Z} \\times \\mathbb{Q} \\times \\mathbb{Z}\\), or a 2D vector of rationals.\nWe can replace the vector separator \\(\\#\\) with either a new symbol \\(;\\) or an additional \\(\\#\\) \\[\\left&lt;\\begin{pmatrix} \\frac{a}{b} \\\\ \\frac{c}{d} \\end{pmatrix}\\right&gt; = \\left&lt;a\\right&gt;\\#\\left&lt;b\\right&gt;;\\left&lt;c\\right&gt;\\#\\left&lt;d\\right&gt;\\]\nTo get back to Binary alphabet we can use the following encoding: \\[\ne(s) = \\begin{cases}\n    00 \\; s = 0 \\\\\n    01 \\; s = 1 \\\\\n    10 \\; s = \\# \\\\\n    11 \\; s = \\; ;\n\\end{cases}\n\\]\n\n\n\n\n\n\n\n\nWarningWhat is the smallest alphabet?\n\n\n\nWhat is the smallest possible alphabet we can construct? How might this alphabet represent different objects?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data, Representations, and Problems</span>"
    ]
  },
  {
    "objectID": "lectures/lecture_2.html#encodings",
    "href": "lectures/lecture_2.html#encodings",
    "title": "2  Data, Representations, and Problems",
    "section": "2.3 Encodings",
    "text": "2.3 Encodings\nEncodings are the technique we use to write symbols in a different alphabet. We apply them on a semi-regular basis in computer science.\nAn encoding is a mapping that converts a symbol to a string in another alphabet \\[e: \\Sigma \\mapsto L \\subseteq \\Gamma^*\\] \\[s \\in \\Sigma \\implies e(s) \\in L \\subseteq \\Gamma^\\ast\\]\n\n\n\n\n\n\nNoteNotation\n\n\n\nWe can also “encode” strings\n\\[\\begin{align*}\n    \\text{Let } &w = s_1 s_2 ... s_n \\in \\Sigma^\\ast \\text{ and } e: \\Sigma \\mapsto L \\subseteq \\Gamma^\\ast \\\\\\\\\n     & e(w) = \\left&lt; w\\right&gt;_e = e(s_1) e(s_2) ... e(s_n) \\in \\Gamma^\\ast\n\\end{align*}\\]\n\n\nThere are two types of encodings:\n\nFixed Width: All encoded strings are the same length\n\nA new symbol is indicated by reaching the end of the fixed length\nExample: ASCII \\[ e: \\Sigma \\mapsto \\Gamma^n \\]\n\nVariable Width: All encoded strings have different lengths \\[ e: \\Sigma \\mapsto \\{ w \\in \\Gamma^\\ast \\mid |w| \\leq n \\} \\]\n\nA new symbol is indicated in some fashion\n\nAll symbols start the same way, but feature different symbols for the rest\nA space between symbols\n\nExample: Morse Code\n\nMorse Code was originally designed as an auditory alphabet. It has three symbols, a short sound (dot), a long sound (dash), and no sound (seperator). However, we can simplify it into a binary alphabet of sound, no sound by defining a dash as the repetition of sound over a fixed time interval (the standard is 3 times the length of a dot).\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAll encodings are representations, just from an alphabet of symbols \\(\\Sigma\\) to strings \\(\\Gamma^\\ast\\) instead of a arbitrary set \\(X\\). Can we make an encoding from a set of strings to another set of strings? \\[ e: \\Sigma^\\ast \\mapsto \\Gamma^\\ast \\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data, Representations, and Problems</span>"
    ]
  },
  {
    "objectID": "lectures/lecture_2.html#problems",
    "href": "lectures/lecture_2.html#problems",
    "title": "2  Data, Representations, and Problems",
    "section": "2.4 Problems",
    "text": "2.4 Problems\nWe want to draw a distinction between an algorithm and a problem.\nWe define a problem, as the class of inputs, and class of outputs for which we are interested in.\n\\[ P: X \\mapsto Y \\]\nAn algorithm is the set of instructions by which we manipulate our inputs into our outputs.\nA good intuition for the distinction is that algorithms can call other algorithms, but they cannot call a problem.\n\n\n\n\n\n\nNote\n\n\n\nTo rely on some prior programming experience, you can imagine that a problem is a “declaration” in code, while the algorithm is the actual “definition”.\nFor example, in C++, in some header (.h) file we write\nunsigned int compute_square(unsigned int n);\nwhich is our “Problem” \\(\\text{COMPUTE\\_SQUARE}: \\mathbb{N} \\mapsto \\mathbb{N}\\).\nand then in a .cpp file we have\nunsigned int compute_square(unsigned int n) {\n    unsigned int n_square = n * n;\n    return n_square;\n}\nas our algorithm.\nThis is not a perfect one-to-one relationship. Our header definition lacks the description of what our output should look like as the full definition of \\(\\text{COMPUTE\\_SQUARE}\\) is \\[ \\text{COMPUTE\\_SQUARE}(n) = n^2 \\] and implementing it in code is itself an almost verbatim description of the problem. Use it as a starting off position.\n\n\nExamples:\n\nPrime Factorisation: Input any natural, output: list of prime numbers \\[P: \\mathbb{N} \\mapsto [\\mathbb{N}]\\]\nDerivative: Input a differentiable function, output the derivative function \\[P: F \\mapsto F^\\prime \\]\nSwap Two Numbers: Input two naturals, output two naturals swapped \\[P: \\mathbb{N} \\times \\mathbb{N} \\mapsto \\mathbb{N} \\times \\mathbb{N}\\]\n\nWe want to “compute” the answer, so we turn the domain and co-domain into a string with representations \\(r_X\\) and \\(r_Y\\) that we can manipulate \\[ P: r_X(X) \\mapsto r_Y(Y) \\]\nA Computational Problem is therefore a function \\(f\\) from one set of strings \\(\\Sigma^\\ast\\) to another set of strings \\(\\Gamma^\\ast\\)\n\\[f: \\Sigma^\\ast \\mapsto \\Gamma^\\ast\\]\nThe most common form however is\n\\[f: \\{\\;0, 1\\;\\}^\\ast \\mapsto \\{\\;0, 1\\;\\}^\\ast\\]\nSometimes, we just want to identify if a given object has some property attached to it\n\nIs this number even?\nIs it a rational?\nCan I take the derivative?\n\nWe call these kinds of a problems a Decision Problem\n\\[f: \\Sigma^\\ast \\mapsto \\{\\; 0, 1 \\;\\}\\]\nIn fact, we can restructure any computational problem into a decision problem.\n\n2.4.1 Decision Problem and Computational Problem Equivalence\nAs an example: Lets take the computation problem of dividing a natural number\n\\[\\begin{align*}\n    \\text{Let } n,m \\in \\mathbb{N}, \\text{ and } \\frac{n}{m} \\in \\mathbb{Q} \\\\\n    \\text{COMPUTE\\_NATURAL\\_DIV}(n,m) &= \\frac{n}{m}\n\\end{align*}\\]\nLet assume an algorithm for \\(\\text{COMPUTE\\_NATURAL\\_DIV}\\) exists, say \\(A\\).\nIf we give \\(A\\) a string natural number pair \\(\\left&lt; n, m \\right&gt;\\) it will output the string \\(\\left&lt; \\frac{n}{m} \\right&gt;\\)\nWe define the Decision problem with \\(n,m,q \\in \\mathbb{N}\\) \\[\\text{IS\\_NATURAL\\_DIV}(n,m,q) = \\begin{cases}\n    1 \\text{ if } \\frac{n}{m} = q \\\\\n    0 \\text{ if } \\frac{n}{m} \\neq q\n\\end{cases}\\]\nLet \\(A\\) be an algorithm that solves \\(\\text{COMPUTE\\_NATURAL\\_DIV}\\).\nWe write a new algorithm \\(B\\) on that solves \\(\\text{IS\\_NATURAL\\_DIV}\\)\ndefine \\(B\\) on input \\(\\left&lt;n,m,q\\right&gt;\\)\n\nIf \\(A(\\left&lt;n,m\\right&gt;) = q\\)\n\nTrue =&gt; Return 1\nFalse =&gt; Return 0\n\n\nAnd now for the reverse:\nLet \\(B\\) be an algorithm that solves \\(\\text{IS\\_NATURAL\\_DIV}\\)\ndefine \\(A\\) on input \\(\\left&lt;n,m\\right&gt;\\):\n\nfor \\(q\\) in \\([1, n]\\)\n\nif \\(B(\\left&lt;n,m,q\\right&gt;) = 1\\)\n\nTrue =&gt; return q\nFalse =&gt; do nothing\n\n\nreturn \\(\\left&lt;0\\right&gt;\\)\n\nAlgorithm \\(A\\) solves \\(\\text{COMPUTE\\_NATURAL\\_DIV}\\) as:\n\nIf \\(n &lt; m\\) then \\(\\frac{n}{m} \\notin \\mathbb{N}\\) and no answer exists or \\(n = 0\\) therefore the loop will never have a \\(q\\) with \\(B(\\left&lt;n,m,q\\right&gt;) = 1\\), thus we return \\(\\left&lt; 0\\right&gt;\\)\nIf \\(n = m\\) then \\(\\frac{n}{m} = 1\\), therefore for \\(q = 1\\), we will return \\(q\\)\nIf \\(n &gt; m\\) then \\(n = qm\\)\n\nThe smallest possible \\(q\\) is \\(1\\) and \\(m = n\\)\nThe largest possible \\(q\\) value is \\(q = n\\) and occurs when \\(m = 1\\)\nIf \\(q &gt; n\\) then \\(m &lt; 1\\), thus \\(m \\notin \\mathbb{N}\\), therefore \\(B\\) does not apply\n\n\n\n\n\n\n\n\nWarning\n\n\n\nTry to do the same for a computational problem \\(P\\). Given \\(P: \\{0,1\\}^\\ast \\mapsto \\{0,1\\}^\\ast\\) and algorithm \\(A_P\\), show there exists a decision problem \\(P^\\prime: \\{0,1\\}^\\ast \\mapsto \\{0,1\\}\\)\n\n\n\n\n2.4.2 Language and Decision Problem Equivalence\nLanguages are equivalent to decision problems. We can construct a decision problem out of language membership, and we can construct language membership out of a decision problem.\n\\[ w \\in L \\iff D(w) = 1 \\]\n\n\n\n\n\n\nNote\n\n\n\nShow \\(D(w) = 1 \\implies w \\in L\\)\n\nLet \\(D: \\Sigma^\\ast \\mapsto \\{0, 1\\}\\) be a decision problem.\nDefine the language \\(L\\) as \\[ L = \\{ w \\in \\Sigma^\\ast \\mid D(w) = 1 \\} \\]\n\nShow \\(w \\in L \\implies D(w) = 1\\)\n\nLet \\(L \\subseteq \\Sigma^\\ast\\) be a language.\nDefine the decision problem \\(D\\) as \\[ D(w) = \\begin{cases} 1 & w \\in L \\\\ 0 & w \\notin L \\end{cases} \\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data, Representations, and Problems</span>"
    ]
  }
]